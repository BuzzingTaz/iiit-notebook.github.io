I"Æ<h1 id="cs0101---computer-programming--lecture-003-18-sep-2020-friday">CS0.101 - Computer Programming | Lecture 003, 18 Sep 2020, Friday</h1>
<p>with Prof. Suresh Purini</p>

<h2 id="program-printing-a-pun">Program: Printing a pun</h2>
<pre><code class="language-C">    /* pun.c */
    #include&lt;stdio.h&gt;

    int main(void) {
	printf("To C or not to C: that is the question.\n");
        return 0;
        }
</code></pre>

<p>The above is a program in C to simply print the given string to the screen. <code class="language-plaintext highlighter-rouge">main</code> is a compulsory function and <code class="language-plaintext highlighter-rouge">void</code> is a keyword used here to denote that the function does not take any arguments.
Upon compilation, this file, saved as <em>pun.c</em>, gets converted to an executable, <em>a.out</em> by default when using gcc.
<code class="language-plaintext highlighter-rouge">gcc pun.c</code></p>

<p><strong>pun.c</strong> (C source) ASCII    == gcc ==&gt; <strong>a.out</strong> (x86-64) Instruction set executable</p>

<h3 id="preprocessing">Preprocessing</h3>

<p>The <code class="language-plaintext highlighter-rouge">#include&lt;stdio.h&gt;</code> statement tells the preprocessor to include this library so that we can use the <code class="language-plaintext highlighter-rouge">printf</code> function which is present in this library.
We can see the output after preprocessing by using <code class="language-plaintext highlighter-rouge">cpp pun.c</code> and the preprocessed output is printed to stdout.
The preprocessor obeys commands that begin with â€˜#â€™ (known as <strong>directives</strong>). In the preprocessed file for pun.c, <em>pun.i</em> (which can be created by running <code class="language-plaintext highlighter-rouge">cpp pun.c &gt; pun.i</code>), we can see on a line that there is a <em>function type signature</em>, for the <code class="language-plaintext highlighter-rouge">printf</code> function.</p>

<h3 id="compilation">Compilation</h3>

<p>After preprocessing, the program has to be compiled, which converts it from C source code to machine instructions (object code).
<code class="language-plaintext highlighter-rouge">gcc -c pun.c</code> creates pun.o, an object file, which is not yet ready for execution.
If we want to see the assembly code, we can do that too by using <code class="language-plaintext highlighter-rouge">gcc -S pun.c -o pun.s</code>.</p>

<h3 id="linking">Linking</h3>

<p>Before execution, the object file has to be linked to the standard IO library from which it is calling the <code class="language-plaintext highlighter-rouge">printf</code> function. This is done by the linker. Note that the preprocessed file only contains the function type signature of the <code class="language-plaintext highlighter-rouge">printf</code> function, and not the actual definition of the function, thus linking is needed in order to run the program.</p>

<h2 id="looking-at-a-simple-loop">Looking at a simple loop</h2>

<p>If we write the following C code:</p>
<pre><code class="language-C">    /* loop.c */
    int main(void) {
        while(1);
    }
</code></pre>

<p>We end up in an infinite loop. We can look at this simple infinite loop program in greater detail in its assembly form, by running <code class="language-plaintext highlighter-rouge">gcc -S loop.c -o loop.s</code>.
Here we look into how this program is executed, and on line 14 in the assembly code we see</p>
<pre><code class="language-asm">    .L2:
	    jmp	.L2
</code></pre>

<p>This means that at the memory address <code class="language-plaintext highlighter-rouge">.L2</code> there is a call for a jump statement, which sends the program counter again to <code class="language-plaintext highlighter-rouge">L2</code> and this is how our infinite loop functions.
And if we compile and execute this program we can take note of something interesting. Opening up a program like <code class="language-plaintext highlighter-rouge">htop</code> allows us to see that while our program is running, we have a CPU load of 100% on one of our cores!
In fact, if we load more instances of this loop on different terminals, we get more and more cores running at 100%, until we run out of cores, but interestingly, our computer does not crash when this happens.</p>

<p>On my system, I did not even experience any significant lag due to this. This is because the computer is able to appropriately <strong>timeshare</strong> these processes.
The various threads running on this computer are rapidly switched between in order to do this, and this does not make it immune to slowdown. Given enough processes, the computer will start to feel laggy and slow, and eventually will crash.
It is possible to write a shell script to do exactly this, crash the system by running too many processes, and it is known as a <strong>fork bomb</strong></p>

<p>On bash:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    bomb<span class="o">()</span> <span class="o">{</span> 
     bomb | bomb &amp;
    <span class="o">}</span><span class="p">;</span> bomb
</code></pre></div></div>

<p>This defines a function called bomb in bash, and then calls it, and pipes its output to another instance of bomb. The â€˜&amp;â€™ places it in the background so the recursive loop can continue.
This rapidly spawns multiple instances of the bomb process and thus crashes your computer.
<a href="https://www.cyberciti.biz/faq/understanding-bash-fork-bomb/">Further reading on the bash fork bomb</a></p>
:ET